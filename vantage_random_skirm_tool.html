<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vantage Skirm Card Pool</title>
<style>
  :root{
    --bg:#f7fbff;--card:#fff;--ink:#10324a;--muted:#5a7b91;--accent:#3a8ad8;--chip:#e6f2ff;
    --ok:#1f9d55;--err:#b00020;--radius:12px;
    --bigW:280px;--miniW:180px;
  }
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,"Noto Sans TC",sans-serif}
  header{padding:24px 16px;text-align:center}
  header h1{margin:0 0 6px}
  .wrap{max-width:1100px;margin:0 auto;padding:0 16px 60px}
  .panel{background:var(--card);border:1px solid #e6eef7;border-radius:var(--radius);
         box-shadow:0 2px 8px rgba(16,50,74,.06);padding:14px;margin-top:14px}
  .btn{border:1px solid #cfe2f3;background:var(--chip);padding:8px 12px;border-radius:10px;cursor:pointer}
  .btn.primary{background:var(--accent);border-color:var(--accent);color:#fff}
  .btn.ghost{background:#fff}
  .kpi{background:#f1f7ff;border:1px dashed #cfe2f3;border-radius:10px;padding:8px 10px;display:inline-block;margin-right:10px}

  /* Card aspect ratio 63:88 */
  .card{
    position:relative;width:var(--bigW);aspect-ratio:63/88;border:1px solid #dfe7f1;
    border-radius:16px;background:#fff;padding:12px;box-shadow:0 6px 18px rgba(16,50,74,.08);
    display:flex;flex-direction:column;overflow:hidden
  }
  .card--mini{
    width:var(--miniW);aspect-ratio:63/88;padding:10px;border-radius:14px;
    box-shadow:0 3px 10px rgba(16,50,74,.06);display:flex;flex-direction:column;
    cursor:pointer;transition:transform .05s ease
  }
  .card--mini:active{transform:scale(0.99)}
  .card h3{margin:0 0 6px;font-size:20px;line-height:1.2}
  .card--mini h3{font-size:14px;margin-bottom:4px}

  .badge{position:absolute;right:10px;top:10px;font-size:12px;background:#fff3cd;
         border:1px solid #ffe08a;color:#8a6d3b;border-radius:999px;padding:2px 8px}

  .pill{display:inline-flex;align-items:center;gap:6px;background:#e6f2ff;padding:3px 9px;border-radius:999px;
        margin-right:6px;font-size:13px}
  .tag{display:inline-block;border-radius:6px;padding:4px 8px;font-size:15px;color:#fff;
       margin-right:6px;white-space:nowrap}
  .Move{background:#3a8ad8}.Look{background:#8e44ad}.Engage{background:#e67e22}
  .Help{background:#27ae60}.Take{background:#f1c40f;color:#000}.Overpower{background:#c0392b}

  .mini{font-size:12px;color:var(--muted)}

  /* Draw History grid */
  #history.history-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(var(--miniW),1fr));gap:12px}

  /* Push Element/Gear to bottom of the card */
  .spacer{flex:1 1 auto}
  .line{font-size:15px}
  .card--mini .line{font-size:12px}
</style>
</head>
<body>
<header>
  <h1>Vantage Skirm Card Pool</h1>
  <p>Auto-imports on load. Excluded cards appear in Draw History.</p>
</header>

<div class="wrap">
  <!-- Exclusions -->
  <section class="panel">
    <h2>Mark Previously Drawn (Exclude)</h2>
    <div class="mini">Enter card IDs separated by comma or space (e.g., <code>S002 S006</code>)</div>
    <div style="margin-top:8px;display:flex;gap:8px">
      <input id="excludeInput" type="text" placeholder="S002, S006...">
      <button id="btnExclude" class="btn">Add</button>
      <button id="btnClearExcluded" class="btn">Clear</button>
    </div>
    <div id="excludedList" style="margin-top:8px"></div>
  </section>

  <!-- Controls -->
  <section class="panel">
    <h2>Draw Controls</h2>
    <div>
      <span class="kpi">Deck: <span id="deckCount">0</span></span>
      <span class="kpi">Remaining: <span id="remainCount">0</span></span>
      <span class="kpi">Drawn: <span id="drawnCount">0</span></span>
    </div>
    <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap">
      <button id="btnShuffle" class="btn">Shuffle</button>
      <button id="btnReset" class="btn">Reset</button>
      <button id="btnDraw1" class="btn primary">Draw</button>
      <button id="btnDownload" class="btn ghost">Download JPG</button>
    </div>
  </section>

  <!-- Latest -->
  <section class="panel">
    <h2>Latest Draw</h2>
    <div id="last" class="mini">No card drawn yet</div>
  </section>

  <!-- History -->
  <section class="panel">
    <h2>Draw History</h2>
    <div id="history" class="history-grid"></div>
  </section>
</div>

<script>
/* ===== Constants ===== */
const ELEMENTS=["CIRCUIT","WIND","ENERGY","FIRE","GOLD","SINEW","METAL","SAND","STONE","LEAF","WATER","WOOD"];
const GEARS=["MASK","HORN","GAUNTLET","SCEPTER","HELM","HARNESS","CLOAK","TOME","DODECAHEDRON","MANTLE","BLADE","TOOLS"];
const SKILL_COLORS={Move:"#3a8ad8",Look:"#8e44ad",Engage:"#e67e22",Help:"#27ae60",Take:"#f1c40f",Overpower:"#c0392b"};
const GEAR_EMOJI="âš¡";

/* ðŸ”§ Element color + icon (your hosted PNGs). You can replace these URLs. */
const ELEMENT_STYLE={
  CIRCUIT:{color:"#7cc6ff",icon:"https://zak5325.github.io/vantage_element_icon/i-circuit.png"},
  WIND   :{color:"#ff9dc8",icon:"https://zak5325.github.io/vantage_element_icon/i-wind.png"},
  ENERGY :{color:"#b990ff",icon:"https://zak5325.github.io/vantage_element_icon/i-energy.png"},
  FIRE   :{color:"#ffa733",icon:"https://zak5325.github.io/vantage_element_icon/i-fire.png"},
  GOLD   :{color:"#f6c85f",icon:"https://zak5325.github.io/vantage_element_icon/i-gold.png"},
  SINEW  :{color:"#ff8a8a",icon:"https://zak5325.github.io/vantage_element_icon/i-sinew.png"},
  METAL  :{color:"#c1d6e3",icon:"https://zak5325.github.io/vantage_element_icon/i-metal.png"},
  SAND   :{color:"#f0caa6",icon:"https://zak5325.github.io/vantage_element_icon/i-sand.png"},
  STONE  :{color:"#a9b7c4",icon:"https://zak5325.github.io/vantage_element_icon/i-stone.png"},
  LEAF   :{color:"#74d37e",icon:"https://zak5325.github.io/vantage_element_icon/i-leaf.png"},
  WATER  :{color:"#6bb6ff",icon:"https://zak5325.github.io/vantage_element_icon/i-water.png"},
  WOOD   :{color:"#c48f62",icon:"https://zak5325.github.io/vantage_element_icon/i-wood.png"}
};

/* Source (auto-import) */
const DEFAULT_PRIMARY="https://raw.githubusercontent.com/zak5325/zak5325.github.io/main/skirm_cardlist.txt";

/* State */
let FULL=[],DECK=[],DRAWN=[];
const EXCLUDED=new Set();
let CURRENT_BIG_CARD=null;

/* DOM */
const $=id=>document.getElementById(id);
const deckCountEl=$("deckCount"),remainCountEl=$("remainCount"),drawnCountEl=$("drawnCount");
const historyView=$("history"),lastView=$("last"),excludedListEl=$("excludedList");

/* ===== Preload element icons as dataURL (so JPG export keeps them) ===== */
let ICONS_READY = null;

async function blobToDataURL(blob){
  return new Promise((resolve, reject)=>{
    const fr = new FileReader();
    fr.onload = ()=>resolve(fr.result);
    fr.onerror = reject;
    fr.readAsDataURL(blob);
  });
}
async function preloadElementIcons(){
  const entries = Object.entries(ELEMENT_STYLE);
  await Promise.all(entries.map(async ([name, st])=>{
    if(!st || !st.icon) return;
    try{
      const res = await fetch(st.icon, { mode:"cors", cache:"force-cache" });
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const blob = await res.blob();
      st.iconData = await blobToDataURL(blob);
    }catch(err){
      console.warn("Icon preload failed:", name, err);
      st.iconData = null;
    }
  }));
}
ICONS_READY = preloadElementIcons();

/* ===== Parse ===== */
function sanitizeText(t){if(t && t.charCodeAt(0)===0xFEFF) t=t.slice(1);return t;}
function parseLine(l){
  const id=l.match(/^S(\d{3})/i);const sp=l.match(/Speed\s+(\d{1,2})/i);
  if(!id||!sp)return null;
  let e=null,ei=-1,g=null,gi=-1;
  for(const x of ELEMENTS){const p=l.indexOf(x+":");if(p!=-1&&(ei==-1||p<ei)){ei=p;e=x;}}if(ei===-1)return null;
  for(const x of GEARS){const p=l.lastIndexOf(x+":");if(p>gi){gi=p;g=x;}}if(gi===-1)return null;
  const skills=Array.from(l.matchAll(/\[([^\]]+)\]/g)).map(m=>m[1]);
  const et=l.slice(ei+(e.length+1),gi).replace(/^\s*-\s*/,'').trim();
  const gt=l.slice(gi+(g.length+1)).trim();
  return{id:"S"+id[1],speed:+sp[1],skills,element:e,elementText:et,gear:g,gearText:gt};
}
function parseTXT(t){return sanitizeText(t).split(/\r?\n/).map(s=>s.trim()).filter(Boolean).map(parseLine).filter(Boolean);}

/* ===== Render (page) ===== */
function renderSkills(skills){return skills.map(s=>`<span class="tag ${s}">${s}</span>`).join(" ");}

/* Element pill on page: [icon] ElementName */
function elementBadgeHTML(elemName){
  const st = ELEMENT_STYLE[elemName] || { color:"#ccc" };
  const iconHTML = st.icon
    ? `<img src="${st.icon}" width="18" height="18" style="vertical-align:-3px;border-radius:3px;object-fit:cover">`
    : "";
  return `<span class="pill">${iconHTML}${elemName}</span>`;
}

/* Card DOM (Element/Gear fixed to bottom using .spacer) */
function renderCard(c,{mini=false}={}){
  const el=document.createElement("div");
  el.className="card"+(mini?" card--mini":"");
  el.innerHTML=`
    <h3>${c.id} Â· Speed ${c.speed}</h3>
    <div>${renderSkills(c.skills)}</div>
    <div class="spacer"></div>
    <div class="line">${elementBadgeHTML(c.element)} ${c.elementText}</div>
    <div class="line"><span class="pill" title="Resolves first">âš¡ ${c.gear}</span> ${c.gearText}</div>`;
  if(c._excluded)el.innerHTML+=`<div class="badge">Previously drawn (excluded)</div>`;
  if(mini){ el.title="Click to preview as big card"; el.onclick=()=>showAsBigCard(c); }
  return el;
}

/* ===== Deck / State ===== */
function refreshStats(){deckCountEl.textContent=FULL.length;remainCountEl.textContent=DECK.length;drawnCountEl.textContent=DRAWN.filter(c=>!c._excluded).length;}
function resetDeck(){
  DECK=FULL.filter(c=>!EXCLUDED.has(c.id));
  DRAWN=Array.from(EXCLUDED).map(id=>({...FULL.find(c=>c.id===id),_excluded:true}));
  lastView.textContent="No card drawn yet";
  historyView.innerHTML="";
  DRAWN.forEach(c=>historyView.prepend(renderCard(c,{mini:true})));
  refreshStats();
}
function showAsBigCard(c){CURRENT_BIG_CARD=c;lastView.innerHTML="";lastView.append(renderCard(c));}
function drawOne(){if(!DECK.length)return;const i=Math.floor(Math.random()*DECK.length);const c=DECK.splice(i,1)[0];DRAWN.push(c);showAsBigCard(c);historyView.prepend(renderCard(c,{mini:true}));refreshStats();}
$("btnShuffle").onclick=()=>DECK.sort(()=>Math.random()-0.5);
$("btnReset").onclick=resetDeck;
$("btnDraw1").onclick=drawOne;

/* ===== Exclusions ===== */
$("btnExclude").onclick=()=>{
  const raw=$("excludeInput").value.trim();
  if(!raw) return;
  raw.split(/[,\s]+/).forEach(id=>{ if(id) EXCLUDED.add(id.toUpperCase()); });
  $("excludeInput").value="";
  resetDeck();
};
$("btnClearExcluded").onclick=()=>{EXCLUDED.clear();resetDeck();};

function renderExcludedList(){
  const el=excludedListEl; el.innerHTML="";
  if(EXCLUDED.size===0){el.innerHTML=`<div class="mini">No excluded cards.</div>`;return;}
  const byId=new Map(FULL.map(c=>[c.id,c]));
  Array.from(EXCLUDED).sort().forEach(id=>{
    const c=byId.get(id);
    const row=document.createElement("div");
    row.className="mini";
    row.textContent = `${id}${c?` Â· Speed ${c.speed}`:""}`;
    el.appendChild(row);
  });
}

/* ===== Auto import deck from fixed URL ===== */
(async()=>{
  try{
    const res=await fetch(DEFAULT_PRIMARY,{cache:"no-store"});
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const txt=await res.text();
    FULL=parseTXT(txt);
    resetDeck();
    renderExcludedList();
  }catch(e){
    console.error("Failed to load card list:", e);
  }
})();

/* ===== JPG Export (Element/Gear pinned to bottom; icon on same line as Element name) ===== */

/* Simple word-wrap by char length */
function wrapWords(str,maxChars){
  const words=String(str||"").split(/\s+/);
  const lines=[]; let cur="";
  for(const w of words){
    const t=cur?cur+" "+w:w;
    if(t.length<=maxChars){cur=t;}
    else{ if(cur)lines.push(cur); cur=w; }
  }
  if(cur)lines.push(cur);
  return lines;
}
/* Pills drawing (SVG) */
function skillPillsSVG(skills,x,y,maxW){
  const h=34,padX=12,gap=8,vgap=8;let cx=x,cy=y,out="";
  skills.forEach(s=>{
    const w=18+String(s).length*10;
    if(cx+w>x+maxW){cx=x;cy+=h+vgap;}
    const color=SKILL_COLORS[s]||"#999"; const textColor=(s==="Take")?"#000":"#fff";
    out+=`<rect x="${cx}" y="${cy}" rx="7" ry="7" width="${w}" height="${h}" fill="${color}"/>`;
    out+=`<text x="${cx+padX}" y="${cy+22}" font-size="15" font-family="system-ui, sans-serif" fill="${textColor}">${s}</text>`;
    cx+=w+gap;
  });
  return {svg:out,lastY:cy+h};
}

/* Build export SVG
 * - Gear at the very bottom
 * - Element above Gear
 * - Element icon image placed on same line as Element name (with safe spacing & baseline)
 */
function buildCardSVG(card){
  const W=630,H=880,pad=24,innerW=W-2*pad;
  const title=`${card.id} Â· Speed ${card.speed}`;
  const bg=(ELEMENT_STYLE[card.element]||{}).color||"#cfe2f3";
  const iconData=(ELEMENT_STYLE[card.element]||{}).iconData;

  // Top: title + skills
  const titleY=78;
  const skillsTopY=116;
  const pills=skillPillsSVG(card.skills||[],pad,130,innerW);

  // Bottom layout metrics (tuned to avoid any overlap)
  const nameFontSize=22;        // Element name font size
  const lineH=26;               // wrap line height
  const labelH=22;              // "Element"/"Gear" label height
  const nameLineExtraGap=10;    // extra gap below the name row before description
  const blockGap=18;            // gap between Element and Gear blocks
  const bottomPad=pad;

  // Split Element: first line is [icon] ElementName, description wraps below
  const elName = card.element;
  const elDescLines = wrapWords(card.elementText, 48);
  const grLines = wrapWords(`${GEAR_EMOJI} ${card.gear}: ${card.gearText}`, 44);

  // Heights
  const elNameH = nameFontSize + 4;             // name row height
  const elDescH = elDescLines.length * lineH;
  const elBlockH = labelH + elNameH + nameLineExtraGap + elDescH;

  const grTextH = grLines.length * lineH;
  const grBlockH = labelH + grTextH;

  // Pin Gear to bottom; Element sits above it
  const gearStartY = H - bottomPad - grBlockH;
  const elemStartY = gearStartY - blockGap - elBlockH;

  // Element name row positions (icon + name)
  const elIconSize = 26;
  const elIconMargin = 12;                            // space between icon and name
  const elIconX = pad + 12;
  const elNameX = iconData ? elIconX + elIconSize + elIconMargin : pad + 12;
  const elNameBaselineY = elemStartY + labelH + nameFontSize;   // baseline for name
  const elIconY = elNameBaselineY - elIconSize + 6;             // visual center to baseline

  // Element description lines start AFTER an extra gap
  const elDescStartY = elemStartY + labelH + elNameH + nameLineExtraGap;

  // Build text SVGs
  const elDescSVG = elDescLines.map((t,i)=>
    `<text x="${pad+12}" y="${elDescStartY + i*lineH}" font-size="20" font-family="system-ui, sans-serif" fill="#10324a">${t}</text>`
  ).join("");

  const grTextSVG = grLines.map((t,i)=>
    `<text x="${pad+12}" y="${gearStartY + labelH + i*lineH}" font-size="20" font-family="system-ui, sans-serif" fill="#10324a">${t}</text>`
  ).join("");

  const elIconSVG = iconData
    ? `<image href="${iconData}" x="${elIconX}" y="${elIconY}" width="${elIconSize}" height="${elIconSize}" preserveAspectRatio="xMidYMid slice" />`
    : "";

  const excludedBadge = card._excluded
    ? `<rect x="${W-220}" y="16" rx="14" ry="14" width="204" height="30" fill="#fff3cd" stroke="#ffe08a"/>
       <text x="${W-118}" y="36" font-size="12" text-anchor="middle" font-family="system-ui, sans-serif" fill="#8a6d3b">Previously drawn (excluded)</text>`
    : "";

  return `
<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}">
  <!-- Background with Element color -->
  <rect x="0" y="0" width="${W}" height="${H}" fill="${bg}"/>

  <!-- Inner frame -->
  <rect x="10" y="10" width="${W-20}" height="${H-20}" rx="22" ry="22" fill="${bg}" stroke="#dfe7f1"/>

  <!-- Title -->
  <text x="${pad}" y="${titleY}" font-size="34" font-weight="700" font-family="system-ui, sans-serif" fill="#10324a">${title}</text>

  <!-- Skills -->
  <text x="${pad}" y="${skillsTopY}" font-size="18" font-family="system-ui, sans-serif" fill="#2b4a60">Skills</text>
  ${pills.svg}

  <!-- Element block -->
  <text x="${pad}" y="${elemStartY}" font-size="18" font-family="system-ui, sans-serif" fill="#2b4a60">Element</text>
  ${elIconSVG}
  <text x="${elNameX}" y="${elNameBaselineY}" font-size="${nameFontSize}" font-family="system-ui, sans-serif" font-weight="700" fill="#10324a">${elName}</text>
  ${elDescSVG}

  <!-- Gear block -->
  <text x="${pad}" y="${gearStartY}" font-size="18" font-family="system-ui, sans-serif" fill="#2b4a60">Gear</text>
  ${grTextSVG}

  ${excludedBadge}
</svg>`;
}

/* Download JPG: wait icons preloaded, then render SVG -> Canvas -> JPG */
async function downloadCurrentBigCard(){
  if(!CURRENT_BIG_CARD) return;
  try{ await ICONS_READY; }catch{}
  const svg=buildCardSVG(CURRENT_BIG_CARD);
  const blob=new Blob([svg],{type:"image/svg+xml"});
  const url=URL.createObjectURL(blob);
  const img=new Image();
  img.onload=()=>{
    const canvas=document.createElement("canvas");
    canvas.width=img.width;canvas.height=img.height;
    const ctx=canvas.getContext("2d");
    ctx.drawImage(img,0,0);
    URL.revokeObjectURL(url);
    const jpg=canvas.toDataURL("image/jpeg",0.95);
    const a=document.createElement("a");a.href=jpg;a.download=`${CURRENT_BIG_CARD.id}.jpg`;a.click();
  };
  img.src=url;
}
$("btnDownload").onclick=downloadCurrentBigCard;

/* ===== Auto-import ===== */
(async()=>{
  try{
    const res=await fetch(DEFAULT_PRIMARY,{cache:"no-store"});
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const txt=await res.text();
    FULL=parseTXT(txt);
    resetDeck();
    renderExcludedList();
  }catch(e){
    console.error("Failed to load card list:", e);
  }
})();
</script>
</body>
</html>
